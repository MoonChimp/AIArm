<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus Consciousness System</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: rgb(0, 191, 255);
            --primary-dark: rgb(0, 128, 255);
            --secondary-color: rgb(138, 43, 226);
            --dark-bg: rgb(16, 24, 39);
            --darker-bg: rgb(10, 15, 25);
            --text-light: rgb(229, 231, 235);
            --text-dim: rgba(229, 231, 235, 0.7);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, var(--darker-bg), var(--dark-bg));
            color: var(--text-light);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            min-height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.2);
            border-right: 1px solid rgba(0, 191, 255, 0.2);
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(45deg, var(--primary-color), var(--primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .subtitle {
            font-size: 12px;
            color: var(--text-dim);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .agent-list {
            margin-bottom: 30px;
        }
        
        .agent-list h3 {
            font-size: 14px;
            color: var(--primary-color);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .agent {
            background: rgba(0, 191, 255, 0.05);
            border: 1px solid rgba(0, 191, 255, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .agent:hover {
            background: rgba(0, 191, 255, 0.1);
            transform: translateY(-2px);
        }
        
        .agent.active {
            background: rgba(0, 191, 255, 0.2);
            border-color: rgba(0, 191, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 191, 255, 0.2);
        }
        
        .agent-name {
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .agent-type {
            font-size: 12px;
            color: var(--text-dim);
        }
        
        .status-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 191, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
        }
        
        .status-panel h3 {
            font-size: 14px;
            color: var(--primary-color);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
        }
        
        .status-label {
            color: var(--text-dim);
        }
        
        .status-value {
            color: var(--primary-color);
            font-weight: 500;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            padding: 20px;
            border-bottom: 1px solid rgba(0, 191, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .header h2 {
            font-size: 20px;
            font-weight: 600;
        }
        
        .header p {
            font-size: 14px;
            color: var(--text-dim);
            margin-top: 5px;
        }
        
        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .welcome {
            text-align: center;
            padding: 50px 0;
        }
        
        .welcome h3 {
            font-size: 22px;
            margin-bottom: 15px;
        }
        
        .welcome p {
            color: var(--text-dim);
            max-width: 500px;
            margin: 0 auto;
        }
        
        .message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            max-width: 80%;
        }
        
        .message.user {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.2);
            margin-left: auto;
        }
        
        .message.agent {
            background: rgba(0, 191, 255, 0.05);
            border: 1px solid rgba(0, 191, 255, 0.1);
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .message-sender {
            font-weight: 600;
        }
        
        .message-time {
            font-size: 12px;
            color: var(--text-dim);
        }
        
        .message-content {
            line-height: 1.5;
            font-size: 14px;
            white-space: pre-wrap;
        }
        
        .input-area {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-top: 1px solid rgba(0, 191, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .input-container {
            display: flex;
            align-items: flex-end;
            gap: 10px;
        }
        
        textarea {
            flex: 1;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(0, 191, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-light);
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            resize: none;
            height: 100px;
        }
        
        textarea:focus {
            outline: none;
            border-color: rgba(0, 191, 255, 0.5);
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.2);
        }
        
        button {
            padding: 15px 25px;
            background: linear-gradient(45deg, var(--primary-color), var(--primary-dark));
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            height: 100px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 191, 255, 0.3);
        }
        
        button:disabled {
            background: rgba(150, 150, 150, 0.3);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .input-hint {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 10px;
        }
        
        /* Crystal background effects */
        .crystal-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
        }
        
        .crystal {
            position: absolute;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            background: rgba(0, 191, 255, 0.05);
            border: 1px solid rgba(0, 191, 255, 0.1);
            opacity: 0.2;
        }
        
        /* Processing indicator */
        .processing {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            color: var(--primary-color);
        }
        
        .dot {
            width: 8px;
            height: 8px;
            background: var(--primary-color);
            border-radius: 50%;
            margin: 0 5px;
            animation: pulse 1.5s infinite ease-in-out;
        }
        
        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes pulse {
            0%, 100% { 
                transform: scale(0.8);
                opacity: 0.5;
            }
            50% { 
                transform: scale(1.2);
                opacity: 1;
            }
        }
        
        /* Energy effect */
        .energy-line {
            position: absolute;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
            width: 100%;
            opacity: 0;
            animation: energy-pulse 3s infinite ease-in-out;
        }
        
        @keyframes energy-pulse {
            0% {
                opacity: 0;
                transform: translateY(-50px);
            }
            50% {
                opacity: 0.5;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(50px);
            }
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                max-height: 300px;
                overflow-y: auto;
                border-right: none;
                border-bottom: 1px solid rgba(0, 191, 255, 0.2);
            }
            
            .message {
                max-width: 90%;
            }
        }
        
        .connection-status {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
        }
        
        .connection-status.connected {
            color: #4CAF50;
        }
        
        .connection-status.disconnected {
            color: #F44336;
        }
        
        .spinner {
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            width: 12px;
            height: 12px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Message action buttons */
        .message-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .action-button {
            padding: 8px 15px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }
        
        .action-confirm {
            background: linear-gradient(45deg, var(--primary-color), var(--primary-dark));
            color: white;
        }
        
        .action-confirm:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0, 191, 255, 0.3);
        }
        
        .action-cancel {
            background: rgba(150, 150, 150, 0.1);
            color: var(--text-dim);
            border: 1px solid rgba(150, 150, 150, 0.2);
        }
        
        .action-cancel:hover {
            background: rgba(150, 150, 150, 0.2);
        }
        
        /* Terminal output styling */
        .terminal-output {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            color: #32CD32; /* Terminal green */
            white-space: pre-wrap;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>

    <script>
    function cleanResponse(text) {
        // Remove repetitive prefix
        text = text.replace(/I've processed your request through the HRM architecture. The Surface layer provided structured understanding while the Deep reasoning layer added contextual depth. How else can I assist you\?\s*/g, "");
        
        // Remove orchestrator prefix
        text = text.replace(/Orchestrator \(HRM\)\s*\d{1,2}:\d{1,2}:\d{1,2} [AP]M\s*/g, "");
        
        return text;
    }
    
    // Apply cleaning when a new message is added
    document.addEventListener("DOMNodeInserted", function(e) {
        if (e.target.classList && e.target.classList.contains("assistant-message")) {
            setTimeout(function() {
                e.target.innerHTML = cleanResponse(e.target.innerHTML);
            }, 100);
        }
    });
    </script>
    </head>
<body>
    <!-- Crystal background effects -->
    <div class="crystal-bg" id="crystalBg"></div>
    
    <!-- Connection status indicator -->
    <div class="connection-status" id="connectionStatus">
        Checking connection... <span class="spinner"></span>
    </div>
    
    <div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
        <div class="logo-container" style="display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 20px;">
            <img src="/NexusLogo.gif" alt="Nexus Logo" style="height: 100px; margin-bottom: 10px; mix-blend-mode: screen;">
            <div style="text-align: center;">
                <div class="logo">Nexus AI</div>
                <div class="subtitle">100% LOCAL AI SYSTEM</div>
            </div>
        </div>
            
            <div class="agent-list">
                <h3>Active Agents</h3>
                <div class="agent active" data-agent="orchestrator">
                    <div class="agent-name">Nexus AI</div>
                    <div class="agent-type">Main Intelligence</div>
                </div>
                <div class="agent" data-agent="WebSearch">
                    <div class="agent-name">Web Search</div>
                    <div class="agent-type">Information Retrieval</div>
                </div>
                <div class="agent" data-agent="PhotoGeneration">
                    <div class="agent-name">Photo Generation</div>
                    <div class="agent-type">Image Creation</div>
                </div>
                <div class="agent" data-agent="VideoGeneration">
                    <div class="agent-name">Video Generation</div>
                    <div class="agent-type">Video Production</div>
                </div>
                <div class="agent" data-agent="FileSystem">
                    <div class="agent-name">File System</div>
                    <div class="agent-type">File Operations</div>
                </div>
            </div>
            
            <div class="status-panel">
                <h3>System Status</h3>
                <div class="status-item">
                    <div class="status-label">Active Agents</div>
                    <div class="status-value" id="agentCount">8</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Messages</div>
                    <div class="status-value" id="messageCount">0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">System</div>
                    <div class="status-value" id="systemStatus">Connecting...</div>
                </div>
                <div class="status-item" style="margin-top: 15px; text-align: center;">
                    <a href="/code-assistant" target="_blank" style="color: var(--primary-color); text-decoration: none; display: block; padding: 5px; border: 1px solid rgba(0, 191, 255, 0.3); border-radius: 5px; background: rgba(0, 191, 255, 0.05);">
                        <span style="font-weight: 600;">⚙️ Open Code Assistant</span>
                    </a>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <!-- Header -->
            <div class="header">
                <h2 id="currentAgent">Orchestrator</h2>
                <p id="agentDescription">Central Multi-Agent Coordination System</p>
            </div>
            
            <!-- Messages -->
            <div class="messages" id="messages">
                <div class="welcome">
                    <h3>Nexus AI System</h3>
                    <p>Nexus is now ready to assist you with any tasks. Type your message and press Enter.</p>
                </div>
            </div>
            
            <!-- Input Area -->
            <div class="input-area">
                <div class="input-container">
                    <textarea id="userInput" placeholder="Enter your request here..."></textarea>
                    <button id="submitBtn">Process</button>
                </div>
                <div class="input-hint">
                    Press Enter to submit, Shift+Enter for new line | Active Agent: <span id="activeAgentLabel">Orchestrator</span>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let activeAgent = 'orchestrator';
        let messageCount = 0;
        let connectionAttempts = 0;
        let sessionId = localStorage.getItem('aiarm_session_id') || `session_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
        const MAX_CONNECTION_ATTEMPTS = 5;
        const RETRY_INTERVAL = 2000; // 2 seconds
        const API_URL = window.location.origin; // Use the same origin as the page
        
        // Store session ID in local storage for persistence across page reloads
        localStorage.setItem('aiarm_session_id', sessionId);
        
        // Generate crystal background
        function generateCrystals() {
            const container = document.getElementById('crystalBg');
            const numCrystals = 15;
            
            for (let i = 0; i < numCrystals; i++) {
                const crystal = document.createElement('div');
                crystal.className = 'crystal';
                
                // Random size between 50px and 150px
                const size = Math.random() * 100 + 50;
                
                // Random position
                const posX = Math.random() * 100;
                const posY = Math.random() * 100;
                
                // Set styles
                crystal.style.width = `${size}px`;
                crystal.style.height = `${size}px`;
                crystal.style.left = `${posX}%`;
                crystal.style.top = `${posY}%`;
                crystal.style.transform = `rotate(${Math.random() * 360}deg)`;
                
                // Add energy lines
                const energyLine = document.createElement('div');
                energyLine.className = 'energy-line';
                energyLine.style.top = `${Math.random() * 100}%`;
                energyLine.style.animationDelay = `${Math.random() * 3}s`;
                
                crystal.appendChild(energyLine);
                container.appendChild(crystal);
            }
        }
        
        // Check server connection
async function checkConnection() {
        const connectionStatus = document.getElementById('connectionStatus');
        const systemStatus = document.getElementById('systemStatus');
        
        try {
        const response = await fetch(`${API_URL}/api/status`);
        if (response.ok) {
            const data = await response.json();
            connectionStatus.textContent = 'Connected to AI Orchestrator (Session: ' + sessionId.substring(0, 8) + '...)'; 
            connectionStatus.className = 'connection-status connected';
            systemStatus.textContent = data.status || 'Online';
        
        // Add welcome message from the orchestrator
        setTimeout(() => {
        addMessage('Welcome to the Nexus HRM Architecture System. I am Nexus, combining surface intelligence with deep reasoning capabilities. How can I assist you today?', 'Nexus AI');
        }, 1000);
        
        return true;
        } else {
        throw new Error('Server returned an error response');
        }
        } catch (error) {
        console.error('Connection error:', error);
        connectionStatus.textContent = `Disconnected (Attempt ${connectionAttempts + 1}/${MAX_CONNECTION_ATTEMPTS})`;
        connectionStatus.className = 'connection-status disconnected';
        systemStatus.textContent = 'Offline';
        
        // Retry connection if attempts are below max
        connectionAttempts++;
        if (connectionAttempts < MAX_CONNECTION_ATTEMPTS) {
        setTimeout(checkConnection, RETRY_INTERVAL);
        return false;
        } else {
        // Max attempts reached, show error message
        connectionStatus.textContent = 'Connection failed. Server unavailable.';
        addMessage('Connection to the AI server failed. Please check that the server is running properly and refresh the page to try again. If using Ollama, make sure Ollama is running on port 11434 before starting the server.', 'System', false, true);
        return false;
        }
        }
}
        
        // Agent selection
        function setupAgentSelection() {
            const agents = document.querySelectorAll('.agent');
            const currentAgentTitle = document.getElementById('currentAgent');
            const agentDescription = document.getElementById('agentDescription');
            const activeAgentLabel = document.getElementById('activeAgentLabel');
            
            const agentDescriptions = {
            'orchestrator': 'Human-Robot-Machine Core Intelligence System',
                'WebSearch': 'Search the web for information and retrieve content',
                'PhotoGeneration': 'Generate images based on text descriptions',
                'VideoGeneration': 'Create videos from scripts and descriptions',
                'FileSystem': 'Perform file and directory operations'
            };
            
            agents.forEach(agent => {
                agent.addEventListener('click', () => {
                    // Remove active class from all agents
                    agents.forEach(a => a.classList.remove('active'));
                    
                    // Add active class to clicked agent
                    agent.classList.add('active');
                    
                    // Update header information
                    const agentId = agent.getAttribute('data-agent');
                    const agentName = agent.querySelector('.agent-name').textContent;
                    
                    currentAgentTitle.textContent = agentName;
                    agentDescription.textContent = agentDescriptions[agentId];
                    activeAgentLabel.textContent = agentName;
                    
                    // Store active agent
                    activeAgent = agentId;
                });
            });
        }
        
        // Add message to the messages container
        function addMessage(content, sender, isUser = false, isError = false, withActions = false) {
            const messagesContainer = document.getElementById('messages');
            const messageElement = document.createElement('div');
            
            messageElement.className = `message ${isUser ? 'user' : 'agent'}`;
            if (isError) {
                messageElement.style.borderColor = 'rgba(244, 67, 54, 0.3)';
                messageElement.style.background = 'rgba(244, 67, 54, 0.05)';
            }
            
            const timestamp = new Date().toLocaleTimeString();
            
            // Create the basic message structure
            messageElement.innerHTML = `
                <div class="message-header">
                    <div class="message-sender">${sender}</div>
                    <div class="message-time">${timestamp}</div>
                </div>
                <div class="message-content">${content}</div>
            `;
            
            // Add action buttons if requested
            if (withActions) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                actionsDiv.innerHTML = `
                    <button class="action-button action-confirm">Yes, please do that</button>
                    <button class="action-button action-cancel">No, thanks</button>
                `;
                messageElement.appendChild(actionsDiv);
            }
            
            // Add to messages container
            messagesContainer.appendChild(messageElement);
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Update message count
            messageCount++;
            const messageCountElement = document.getElementById('messageCount');
            messageCountElement.textContent = messageCount;
            
            return messageElement;
        }
        
        // Show processing indicator
        function showProcessing() {
            const messagesContainer = document.getElementById('messages');
            const processingElement = document.createElement('div');
            
            processingElement.className = 'processing';
            processingElement.id = 'processingIndicator';
            
            processingElement.innerHTML = `
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <span style="margin-left: 10px;">Processing with multi-agent coordination...</span>
            `;
            
            messagesContainer.appendChild(processingElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Hide processing indicator
        function hideProcessing() {
            const processingIndicator = document.getElementById('processingIndicator');
            if (processingIndicator) {
                processingIndicator.remove();
            }
        }
        
        // Detect if text contains a task request
        function detectTaskRequest(text) {
                // Keywords that indicate the user wants to perform a task
                const taskKeywords = [
                    // File operations
                    'list', 'show files', 'show me files', 'show the files', 'what files', 'directory', 'folder contents',
                    'view files', 'view folders', 'view directory', 'see files', 'see folders', 'see directory',
                    'read file', 'open file', 'show content', 'get content', 'show the content',
                    'write', 'create file', 'make file', 'save file', 'save to file', 'save content',
                    'delete', 'remove file', 'remove folder', 'erase file', 'get rid of', 'move file', 'rename file',
                    'copy file', 'duplicate file',
                    
                    // Expressed intentions
                    'need to', 'want to', 'looking to', 'trying to', 'like to', 'would like to', 'help me', 'can you help',
                    'organize files', 'organize my files', 'clean up', 'sort files', 'find files', 'locate files',
                    'check if', 'see if', 'could you', 'would you', 'please'
                ];
                
                // Drive patterns (e.g., "C:\")
            if (/^[A-Za-z]:\\?$/.test(text.trim())) {
                return {
                isTask: true,
                    operation: 'list_directory',
                path: text.trim(),
                message: `Would you like me to list the contents of the ${text.trim()} drive?`
        };
        }
        
        // Check for task keywords
        const lowerText = text.toLowerCase();
        for (const keyword of taskKeywords) {
        if (lowerText.includes(keyword.toLowerCase())) {
        // Detect file operations from natural language
        if (/\b(list|show|display|what|what's)\b.*\b(in|of|at|files|folders|directory)\b/i.test(lowerText) && /\b([A-Za-z]:\\|\/)\b/i.test(text)) {
                // Extract path using regex
                    const pathMatch = text.match(/\b([A-Za-z]:\\[^\s,.:;!?"'`]*|\/?[\w\-\.\/ ]+)\b/i);
                    if (pathMatch) {
                        return {
                            isTask: true,
                            operation: 'list_directory',
                            path: pathMatch[1],
                        message: `Would you like me to list the contents of ${pathMatch[1]}?`
                    };
                }
            } else if (/\b(read|open|show|view|display|get|see)\b.*\b(content|file|text)\b/i.test(lowerText) && /\b([A-Za-z]:\\|\/)\b/i.test(text)) {
            const pathMatch = text.match(/\b([A-Za-z]:\\[^\s,.:;!?"'`]*|\/?[\w\-\.\/ ]+\.[\w]+)\b/i);
            if (pathMatch) {
                    return {
                    isTask: true,
                    operation: 'read_file',
                    path: pathMatch[1],
                    message: `Would you like me to read the contents of ${pathMatch[1]}?`
                };
        }
        }
        
        // If no specific operation was detected but we found task keywords,
        // return a generic task detection
        return {
        isTask: true,
        message: `I detect you might want assistance with a task. Could you clarify what specific file operation you'd like me to perform?`
        };
        }
        }
        
        return { isTask: false };
        }
        
        // Execute file system task
        async function executeFileSystemTask(operation, params) {
        try {
        // Create terminal output element
        const terminalOutput = document.createElement('div');
        terminalOutput.className = 'terminal-output';
        terminalOutput.innerHTML = `$ executing ${operation} ${JSON.stringify(params)}\n`;
        
        // Add it to the last message
        const messagesContainer = document.getElementById('messages');
        const lastMessage = messagesContainer.lastElementChild;
        if (lastMessage) {
        const contentDiv = lastMessage.querySelector('.message-content');
        contentDiv.appendChild(terminalOutput);
        }
        
        // Make the API call to the filesystem endpoint
        const response = await fetch(`${API_URL}/api/filesystem`, {
        method: 'POST',
        headers: {
        'Content-Type': 'application/json'
        },
        body: JSON.stringify({
        operation,
        ...params
        })
        });
        
        // Process response
        if (response.ok) {
                const result = await response.json();
            console.log('Filesystem operation result:', result);
            
            // Update terminal output with result
                if (result.success) {
                        let responseMessage = '';
                            
                        switch (operation) {
                            case 'read_file':
                                    responseMessage = `$ cat ${params.path}\n\n${result.content}`;
                                break;
                            case 'write_file':
                                responseMessage = `$ echo "${params.content.substring(0, 50)}${params.content.length > 50 ? '...' : ''}" > ${params.path}\nFile successfully written to ${params.path}`;
                                break;
                            case 'append_file':
                                    responseMessage = `$ echo "${params.content.substring(0, 50)}${params.content.length > 50 ? '...' : ''}" >> ${params.path}\nContent successfully appended to ${params.path}`;
                                break;
                            case 'list_directory':
                                responseMessage = `$ ls -la ${params.path}\n\n`;
                                result.items.forEach(item => {
                                    responseMessage += `${item.type === 'directory' ? 'd' : '-'}rw-r--r-- ${item.name}\n`;
                                });
                                break;
                            case 'create_directory':
                                responseMessage = `$ mkdir ${params.path}\nDirectory successfully created at ${params.path}`;
                                break;
                            case 'delete_file':
                                responseMessage = `$ rm ${params.path}\nFile successfully deleted: ${params.path}`;
                                break;
                            case 'delete_directory':
                                responseMessage = `$ rm${params.recursive ? ' -rf' : ''} ${params.path}\nDirectory successfully deleted: ${params.path}`;
                                break;
                            case 'move_file':
                                responseMessage = `$ mv ${params.source} ${params.destination}\nSuccessfully moved from ${params.source} to ${params.destination}`;
                                break;
                            case 'copy_file':
                                responseMessage = `$ cp ${params.source} ${params.destination}\nSuccessfully copied from ${params.source} to ${params.destination}`;
                                break;
                            case 'get_file_info':
                                responseMessage = `$ stat ${params.path}\n\n`;
                                responseMessage += `Type: ${result.info.is_directory ? 'Directory' : 'File'}\n`;
                                responseMessage += `Size: ${result.info.size} bytes\n`;
                                responseMessage += `Created: ${result.info.created}\n`;
                                responseMessage += `Modified: ${result.info.modified}\n`;
                                responseMessage += `Path: ${result.info.path}\n`;
                                if (result.info.extension) {
                                    responseMessage += `Extension: ${result.info.extension}\n`;
                                }
                                break;
                            case 'search_files':
                                responseMessage = `$ find ${params.directory} -name "*${params.pattern}*"\n\n`;
                                if (result.matches.length === 0) {
                                    responseMessage += 'No matches found.';
                                } else {
                                    result.matches.forEach(item => {
                                        responseMessage += `${item.path}\n`;
                                    });
                                }
                                break;
                            default:
                                responseMessage = `$ ${operation} ${JSON.stringify(params)}\nOperation completed successfully`;
                        }
                        
                        terminalOutput.innerHTML = responseMessage;
                        return { success: true, result };
                    } else {
                        terminalOutput.innerHTML += `Error: ${result.error}\nOperation failed.`;
                        return { success: false, error: result.error };
                    }
                } else {
                    const errorData = await response.json();
                    terminalOutput.innerHTML += `Error: ${errorData.error || 'Server returned an error'}\n${errorData.message || ''}\nOperation failed.`;
                    return { success: false, error: errorData.error };
                }
            } catch (error) {
                console.error('Error executing task:', error);
                return { success: false, error: error.message };
            }
        }
        
        // Submit user input
async function submitUserInput() {
    const userInput = document.getElementById('userInput');
    const submitBtn = document.getElementById('submitBtn');
    
    const input = userInput.value.trim();
    if (!input) return;
    
    // Disable input and button
    userInput.disabled = true;
    submitBtn.disabled = true;
    
    // Add user message
    addMessage(input, 'You', true);
    
    // Show processing indicator
    showProcessing();
    
    try {
        // Check if we're in the File System agent
        if (activeAgent === 'FileSystem') {
            // Check if this is a direct command or natural language
            // Direct commands start with specific keywords
            const directCommands = ['read ', 'write ', 'list ', 'append ', 'mkdir ', 'delete ', 'move ', 'copy ', 'info ', 'search ', 'help'];
            const isDirect = directCommands.some(cmd => input.toLowerCase().startsWith(cmd)) || /^[A-Za-z]:\\?$/.test(input.trim());
            
            if (isDirect) {
                // Handle as direct command
                await handleFileSystemOperation(input);
            } else {
                // Try to detect a task request
                const taskInfo = detectTaskRequest(input);
                
                if (taskInfo.isTask) {
                    // Ask for confirmation
                    hideProcessing();
                    const msgElement = addMessage(taskInfo.message, 'Nexus', false, false, true);
                    
                    // Setup action buttons
                    const confirmBtn = msgElement.querySelector('.action-confirm');
                    const cancelBtn = msgElement.querySelector('.action-cancel');
                    
                    if (confirmBtn && cancelBtn) {
                        // Confirm button
                        confirmBtn.addEventListener('click', async () => {
                            // Remove action buttons
                            const actionsDiv = msgElement.querySelector('.message-actions');
                            if (actionsDiv) actionsDiv.remove();
                            
                            // Add a response message
                            addMessage(`I'm executing that task for you now...`, 'Nexus');
                            
                            // Execute the task if we have operation details
                            if (taskInfo.operation) {
                                const params = {};
                                if (taskInfo.path) params.path = taskInfo.path;
                                if (taskInfo.content) params.content = taskInfo.content;
                                if (taskInfo.source) params.source = taskInfo.source;
                                if (taskInfo.destination) params.destination = taskInfo.destination;
                                if (taskInfo.pattern) params.pattern = taskInfo.pattern;
                                if (taskInfo.directory) params.directory = taskInfo.directory;
                                if (taskInfo.recursive) params.recursive = taskInfo.recursive;
                                
                                const result = await executeFileSystemTask(taskInfo.operation, params);
                                
                                // Add a follow-up message based on result
                                if (result.success) {
                                    addMessage(`Task completed successfully. Is there anything else you'd like to do with these files?`, 'Nexus');
                                } else {
                                    addMessage(`I encountered an issue while trying to complete the task: ${result.error}. Would you like me to try a different approach?`, 'Nexus');
                                }
                            }
                        });
                        
                        // Cancel button
                        cancelBtn.addEventListener('click', () => {
                            // Remove action buttons
                            const actionsDiv = msgElement.querySelector('.message-actions');
                            if (actionsDiv) actionsDiv.remove();
                            
                            // Add a response message
                            addMessage(`No problem. Let me know if you need help with something else.`, 'Nexus');
                        });
                    }
                } else {
                    // Handle as a regular request through the API
                    const response = await fetch(`${API_URL}/api/process`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-Id': sessionId
                        },
                        body: JSON.stringify({
                            input: input,
                            activeAgent: activeAgent,
                            userId: sessionId
                        })
                    });
                    
                    // Hide processing indicator
                    hideProcessing();
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Response from server:', data);
                        
                        // Display the response
                        const responseContent = data.response || data.result || 'No response';
                        addMessage(responseContent, 'Nexus');
                    } else {
                        // Show error message
                        const errorData = await response.json();
                        addMessage(`Error: ${errorData.error || 'Server returned an error'}\n${errorData.message || ''}`, 'System', false, true);
                    }
                }
            }
        } else {
            // Non-FileSystem agent - Process using standard API
            const response = await fetch(`${API_URL}/api/process`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Session-Id': sessionId
                },
                body: JSON.stringify({
                    input: input,
                    activeAgent: activeAgent,
                    userId: sessionId
                })
            });
            
            // Hide processing indicator
            hideProcessing();
            
            if (response.ok) {
                const data = await response.json();
                console.log('Response from server:', data);
                
                if (data.error) {
                    // Show error message
                    addMessage(`${data.error || data.result || data.response || 'Error processing request'}`, activeAgent === 'orchestrator' ? 'Nexus' : document.getElementById('currentAgent').textContent, false, true);
                } else if (data.success) {
                    // Show only the actual AI response - no framing text
                    let responseContent = data.response || data.result || '';
                    
                    // Remove the HRM processing message if present
                    if (typeof responseContent === 'string') {
                        // These patterns match the HRM prefixes that were being repeated
                        const hrmPrefixes = [
                            "I've processed your request through the HRM architecture. The Surface layer provided structured understanding while the Deep reasoning layer added contextual depth. How else can I assist you?\n\n",
                            "Diagnosed system errors and plotted strategic troubleshooting approach.\n\n",
                            "Analyzed your request using Human-Robot-Machine architecture to provide an optimal response.\n\n",
                            "Using the HRM architecture to process your request.\n\n"
                        ];
                        
                        // Check for and remove any of the prefixes
                        for (const prefix of hrmPrefixes) {
                            if (responseContent.startsWith(prefix)) {
                                responseContent = responseContent.substring(prefix.length);
                                break;
                            }
                        }
                    }
                    
                    // If response is a JSON string, parse it
                    if (typeof responseContent === 'string' && (responseContent.startsWith('{') || responseContent.startsWith('['))) {
                        try {
                            const jsonResult = JSON.parse(responseContent);
                            responseContent = JSON.stringify(jsonResult, null, 2);
                        } catch (e) {
                            // Not valid JSON, use as is
                        }
                    }
                    
                    // Show the response without the standard HRM prefix
                    addMessage(responseContent, activeAgent === 'orchestrator' ? 'Nexus' : document.getElementById('currentAgent').textContent);
                } else {
                    // Fallback
                    const fallbackContent = data.response || data.result || 'No response';
                    
                    // Also check for and remove HRM prefix in fallback
                    if (typeof fallbackContent === 'string') {
                        const hrmPrefix = "I've processed your request through the HRM architecture. The Surface layer provided structured understanding while the Deep reasoning layer added contextual depth. How else can I assist you?\n\n";
                        if (fallbackContent.startsWith(hrmPrefix)) {
                            addMessage(fallbackContent.substring(hrmPrefix.length), activeAgent === 'orchestrator' ? 'Nexus' : document.getElementById('currentAgent').textContent);
                        } else {
                            addMessage(fallbackContent, activeAgent === 'orchestrator' ? 'Nexus' : document.getElementById('currentAgent').textContent);
                        }
                    } else {
                        addMessage(fallbackContent, activeAgent === 'orchestrator' ? 'Nexus' : document.getElementById('currentAgent').textContent);
                    }
                }
            } else {
                // Show error message
                const errorData = await response.json();
                addMessage(`Error: ${errorData.error || 'Server returned an error'}\n${errorData.message || ''}`, 'System', false, true);
            }
        }
    } catch (error) {
        hideProcessing();
        addMessage(`Connection error: ${error.message}. Please check that the server is running.`, 'System', false, true);
    } finally {
        // Re-enable input and button
        userInput.disabled = false;
        submitBtn.disabled = false;
        userInput.value = '';
        userInput.focus();
    }
}
        
        // Handle FileSystem operations
        async function handleFileSystemOperation(input) {
            try {
                // Parse the natural language input to determine the file operation
                let operation = '';
                let params = {};
                
                if (input.toLowerCase().startsWith('read ')) {
                    operation = 'read_file';
                    params = { path: input.substring(5).trim() };
                } else if (input.toLowerCase().startsWith('write ')) {
                    // Format: write <path>: <content>
                    const parts = input.substring(6).trim().split(':');
                    if (parts.length >= 2) {
                        const path = parts[0].trim();
                        const content = parts.slice(1).join(':').trim();
                        operation = 'write_file';
                        params = { path, content };
                    } else {
                        throw new Error('Invalid write format. Use: write <path>: <content>');
                    }
                } else if (input.toLowerCase().startsWith('append ')) {
                    // Format: append <path>: <content>
                    const parts = input.substring(7).trim().split(':');
                    if (parts.length >= 2) {
                        const path = parts[0].trim();
                        const content = parts.slice(1).join(':').trim();
                        operation = 'append_file';
                        params = { path, content };
                    } else {
                        throw new Error('Invalid append format. Use: append <path>: <content>');
                    }
                } else if (input.toLowerCase().startsWith('list ')) {
                    operation = 'list_directory';
                    params = { path: input.substring(5).trim() };
                } else if (input.toLowerCase().startsWith('mkdir ')) {
                    operation = 'create_directory';
                    params = { path: input.substring(6).trim() };
                } else if (input.toLowerCase().startsWith('delete file ')) {
                    operation = 'delete_file';
                    params = { path: input.substring(12).trim() };
                } else if (input.toLowerCase().startsWith('delete dir ')) {
                    const parts = input.substring(11).trim().split(' ');
                    const recursive = parts.length > 1 && parts[parts.length - 1].toLowerCase() === 'recursive';
                    const path = recursive ? parts.slice(0, -1).join(' ') : parts.join(' ');
                    operation = 'delete_directory';
                    params = { path, recursive };
                } else if (input.toLowerCase().startsWith('move ')) {
                    // Format: move <source> to <destination>
                    const parts = input.substring(5).trim().split(' to ');
                    if (parts.length === 2) {
                        operation = 'move_file';
                        params = { source: parts[0].trim(), destination: parts[1].trim() };
                    } else {
                        throw new Error('Invalid move format. Use: move <source> to <destination>');
                    }
                } else if (input.toLowerCase().startsWith('copy ')) {
                    // Format: copy <source> to <destination>
                    const parts = input.substring(5).trim().split(' to ');
                    if (parts.length === 2) {
                        operation = 'copy_file';
                        params = { source: parts[0].trim(), destination: parts[1].trim() };
                    } else {
                        throw new Error('Invalid copy format. Use: copy <source> to <destination>');
                    }
                } else if (input.toLowerCase().startsWith('info ')) {
                    operation = 'get_file_info';
                    params = { path: input.substring(5).trim() };
                } else if (input.toLowerCase().startsWith('search ')) {
                    // Format: search <directory> for <pattern>
                    const parts = input.substring(7).trim().split(' for ');
                    if (parts.length === 2) {
                        operation = 'search_files';
                        params = { directory: parts[0].trim(), pattern: parts[1].trim() };
                    } else {
                        throw new Error('Invalid search format. Use: search <directory> for <pattern>');
                    }
                } else if (input.toLowerCase() === 'help') {
                    // Show help message
                    const helpMessage = `
**NexusAI FileSystem Commands:**

- **read <path>** - Read the contents of a file
- **write <path>: <content>** - Write content to a file
- **append <path>: <content>** - Append content to a file
- **list <path>** - List the contents of a directory
- **mkdir <path>** - Create a directory
- **delete file <path>** - Delete a file
- **delete dir <path> [recursive]** - Delete a directory (add 'recursive' to remove non-empty directories)
- **move <source> to <destination>** - Move a file or directory
- **copy <source> to <destination>** - Copy a file or directory
- **info <path>** - Get information about a file or directory
- **search <directory> for <pattern>** - Search for files matching a pattern
- **help** - Show this help message
`;
                    hideProcessing();
                    addMessage(helpMessage, 'FileSystem');
                    return;
                } else {
                    throw new Error(`Unknown command. Type 'help' for a list of available commands.`);
                }
                
                // Make the API call to the filesystem endpoint
                const response = await fetch(`${API_URL}/api/filesystem`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        operation,
                        ...params
                    })
                });
                
                // Hide processing indicator
                hideProcessing();
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Filesystem operation result:', result);
                    
                    if (result.success) {
                        let responseMessage = '';
                        
                        switch (operation) {
                            case 'read_file':
                                responseMessage = `**File Content (${params.path}):**\n\n${result.content}`;
                                break;
                            case 'write_file':
                                responseMessage = `File successfully written to ${params.path}`;
                                break;
                            case 'append_file':
                                responseMessage = `Content successfully appended to ${params.path}`;
                                break;
                            case 'list_directory':
                                responseMessage = `**Directory Listing (${params.path}):**\n\n`;
                                result.items.forEach(item => {
                                    responseMessage += `${item.type === 'directory' ? '[DIR]' : '[FILE]'} ${item.name}\n`;
                                });
                                break;
                            case 'create_directory':
                                responseMessage = `Directory successfully created at ${params.path}`;
                                break;
                            case 'delete_file':
                                responseMessage = `File successfully deleted: ${params.path}`;
                                break;
                            case 'delete_directory':
                                responseMessage = `Directory successfully deleted: ${params.path}`;
                                break;
                            case 'move_file':
                                responseMessage = `Successfully moved from ${params.source} to ${params.destination}`;
                                break;
                            case 'copy_file':
                                responseMessage = `Successfully copied from ${params.source} to ${params.destination}`;
                                break;
                            case 'get_file_info':
                                responseMessage = `**File Information (${params.path}):**\n\n`;
                                responseMessage += `Type: ${result.info.is_directory ? 'Directory' : 'File'}\n`;
                                responseMessage += `Size: ${result.info.size} bytes\n`;
                                responseMessage += `Created: ${result.info.created}\n`;
                                responseMessage += `Modified: ${result.info.modified}\n`;
                                responseMessage += `Path: ${result.info.path}\n`;
                                if (result.info.extension) {
                                    responseMessage += `Extension: ${result.info.extension}\n`;
                                }
                                break;
                            case 'search_files':
                                responseMessage = `**Search Results (${params.pattern} in ${params.directory}):**\n\n`;
                                if (result.matches.length === 0) {
                                    responseMessage += 'No matches found.';
                                } else {
                                    result.matches.forEach(item => {
                                        responseMessage += `${item.type === 'directory' ? '[DIR]' : '[FILE]'} ${item.path}\n`;
                                    });
                                }
                                break;
                            default:
                                responseMessage = `Operation completed successfully: ${operation}`;
                        }
                        
                        addMessage(responseMessage, 'FileSystem');
                    } else {
                        addMessage(`Error: ${result.error}`, 'FileSystem', false, true);
                    }
                } else {
                    const errorData = await response.json();
                    addMessage(`Error: ${errorData.error || 'Server returned an error'}\n${errorData.message || ''}`, 'FileSystem', false, true);
                }
            } catch (error) {
                hideProcessing();
                addMessage(`Error: ${error.message}`, 'FileSystem', false, true);
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Generate crystal background
            generateCrystals();
            
            // Setup agent selection
            setupAgentSelection();
            
            // Setup submit button
            document.getElementById('submitBtn').addEventListener('click', submitUserInput);
            
            // Setup enter key submission
            document.getElementById('userInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    submitUserInput();
                }
            });
            
            // Check connection to server
            checkConnection();
        });
    </script>
</body>
</html>